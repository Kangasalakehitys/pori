[
  {
    "objectID": "verotus.html",
    "href": "verotus.html",
    "title": "Verotus",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "verotus.html#väestönmuutokset---väestöennakko-kolme-ikäluokkaa",
    "href": "verotus.html#väestönmuutokset---väestöennakko-kolme-ikäluokkaa",
    "title": "Verotus",
    "section": "Väestönmuutokset - Väestöennakko, kolme ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, kolme ikäluokkaa\nKuntaliitto käyttää kunnallisveron perustana kolmea ikäluokkaa. Ikäluokittelu huomioi palkansaajat ja eläkeläiset.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\n0-18\n0-18 %\n19-64\n19-64 %\n65+\n65+ %\n\n\n\n\n2000\n84573\n18193\n21.51\n51880\n61.34\n14500\n17.14\n\n\n2001\n84439\n17948\n21.26\n51682\n61.21\n14809\n17.54\n\n\n2002\n84306\n17659\n20.95\n51608\n61.22\n15039\n17.84\n\n\n2003\n84561\n17492\n20.69\n51735\n61.18\n15334\n18.13\n\n\n2004\n84491\n17340\n20.52\n51448\n60.89\n15703\n18.59\n\n\n2005\n84455\n17240\n20.41\n51290\n60.73\n15925\n18.86\n\n\n2006\n84456\n17122\n20.27\n50963\n60.34\n16371\n19.38\n\n\n2007\n84523\n17032\n20.15\n50987\n60.32\n16504\n19.53\n\n\n2008\n84614\n16909\n19.98\n50901\n60.16\n16804\n19.86\n\n\n2009\n84844\n16750\n19.74\n50956\n60.06\n17138\n20.20\n\n\n2010\n85026\n16677\n19.61\n50842\n59.80\n17507\n20.59\n\n\n2011\n85078\n16499\n19.39\n50539\n59.40\n18040\n21.20\n\n\n2012\n85201\n16470\n19.33\n50031\n58.72\n18700\n21.95\n\n\n2013\n85399\n16407\n19.21\n49647\n58.14\n19345\n22.65\n\n\n2014\n85418\n16178\n18.94\n49344\n57.77\n19896\n23.29\n\n\n2015\n85363\n16010\n18.76\n48907\n57.29\n20446\n23.95\n\n\n2016\n85059\n15813\n18.59\n48544\n57.07\n20702\n24.34\n\n\n2017\n84587\n15649\n18.50\n47827\n56.54\n21111\n24.96\n\n\n2018\n84403\n15635\n18.52\n47364\n56.12\n21404\n25.36\n\n\n2019\n83934\n15354\n18.29\n46878\n55.85\n21702\n25.86\n\n\n2020\n83684\n15211\n18.18\n46448\n55.50\n22025\n26.32\n\n\n2021\n83482\n15079\n18.06\n46153\n55.28\n22250\n26.65\n\n\n2022\n83205\n14904\n17.91\n45943\n55.22\n22358\n26.87\n\n\n2023\n83106\n14750\n17.75\n45950\n55.29\n22406\n26.96\n\n\n2024M11*\n83335\n14609\n17.53\n46170\n55.40\n22556\n27.07\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - kolme ikäluokkaa\n\n0-18-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-18-vuotiaiden %-osuus oli 2024M11* yhteensä 17.53. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.38 (2022) ja -0.22 (2023)\n\n\n19-64-vuotiaat\n19-64-vuotiaiden palkansaajien %-osuus oli 2024M11* yhteensä 55.4. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.18 (2022) ja 0.11 (2023)\n\n\n65+-vuotiaat\n65+-vuotiaiden eläkeläisten prosenttiosuus kokonaisuudesta oli 2024M11* yhteensä 27.07. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.2 (2022) ja 0.11 (2023 )"
  },
  {
    "objectID": "verotus.html#ansiotulot",
    "href": "verotus.html#ansiotulot",
    "title": "Verotus",
    "section": "Ansiotulot",
    "text": "Ansiotulot\nTilasto sisältää tuloverotuksen valmistumisen mukaiset tiedot kaikista henkilöasiakkaista. Tilastossa ei huomioida muutosverotuksen tietoja. Lähde: (Vero.fi 2024a)\n\n\n\n\n\n\n\n\nVuosi\nPalkkatulot\nPM %\nEläketulot\nEM %\nTyöttömyysturva\nTM %\nMuut sos.turva\nMM %\nMaa- ja metsätalous\nMTM %\nElinkeinotoiminta\nELM %\nAnsiotulot\nAM %\n\n\n\n\n2014\n1,128,158,598\nNA\n476,871,381\nNA\n83,549,287\nNA\n39,348,705\nNA\n3,956,976\nNA\n66,793,361\nNA\n1,798,678,308\nNA\n\n\n2015\n1,138,482,003\n0.92\n500,040,152\n4.86\n93,473,733\n11.88\n40,416,776\n2.71\n3,922,905\n-0.86\n70,674,960\n5.81\n1,847,010,529\n2.69\n\n\n2016\n1,129,541,591\n-0.79\n510,326,609\n2.06\n97,255,886\n4.05\n40,871,817\n1.13\n4,570,872\n16.52\n71,959,394\n1.82\n1,854,526,169\n0.41\n\n\n2017\n1,159,776,107\n2.68\n521,174,745\n2.13\n85,424,102\n-12.17\n39,970,574\n-2.21\n4,263,828\n-6.72\n74,253,748\n3.19\n1,884,863,104\n1.64\n\n\n2018\n1,203,485,605\n3.77\n531,306,538\n1.94\n69,046,080\n-19.17\n37,753,344\n-5.55\n4,377,256\n2.66\n74,153,542\n-0.13\n1,920,122,365\n1.87\n\n\n2019\n1,228,096,446\n2.04\n544,693,174\n2.52\n67,308,704\n-2.52\n38,511,659\n2.01\n4,198,486\n-4.08\n75,344,235\n1.61\n1,958,152,704\n1.98\n\n\n2020\n1,200,263,350\n-2.27\n557,871,199\n2.42\n89,430,138\n32.87\n40,245,413\n4.50\n4,008,735\n-4.52\n72,079,333\n-4.33\n1,963,898,168\n0.29\n\n\n2021\n1,262,783,867\n5.21\n562,736,047\n0.87\n81,107,364\n-9.31\n41,806,727\n3.88\n4,005,206\n-0.09\n75,720,540\n5.05\n2,028,159,751\n3.27\n\n\n2022\n1,345,305,356\n6.53\n576,472,505\n2.44\n62,837,957\n-22.52\n42,897,892\n2.61\n4,714,226\n17.70\n78,577,949\n3.77\n2,110,805,885\n4.07\n\n\n2023\n1,402,963,587\n4.29\n617,307,855\n7.08\n62,945,316\n0.17\n42,977,189\n0.18\n4,000,590\n-15.14\n77,014,160\n-1.99\nNA\nNA\n\n\n\n\n\n\n\n\nAnsiotulojen kehitys\nPalkkatulot olivat vuonna 2023 yhteensä 1,402,963,587. Muutos edelliseen 2022 vuoteen oli 4.29. Eläketulojen osalta muutos oli 7.08 (7.08)"
  },
  {
    "objectID": "verotus.html#vähennykset",
    "href": "verotus.html#vähennykset",
    "title": "Verotus",
    "section": "Vähennykset",
    "text": "Vähennykset\nTilaston vähennyseristä yleisesti: Jos verovelvolliselle ei ole määrätty verotettavasta tulosta veroja tai niiden määrä on pienempi kuin verosta myönnetty vähennys, myönnettyä vähennystä ei ole voitu vähentää kokonaisuudessaan. Tällaisissa tilanteissa verotuksessa vähennetty määrä on pienempi kuin myönnetty määrä. Sama periaate pätee myös tuloista tehtävien vähennysten osalta.\n*Lyhenteet:\n\nPV % = Palkansaajan vakuutusmaksujen %-osuus palkoista\n\nE % = Eläketulovähennyksen %-osuus eläkkeistä\n\nA % = Vuosittainen muutos ansiotulot-vähennykset*\nLähde: (Vero.fi 2024a)\n\n\n\n\n\n\n\n\nVuosi\nPalkansaajan vak.maksut\nPV %\nVähennetyt matkakustan.\nMuut tulonhankk.vähenn.\nEläketulovähennys\nE %\nAnsiotulovähennys\nPerusvähennys\nMuut vähennykset\nVähennykset yht.\nVäh.aste\nAnsiotulot-vähennykset\nA %\n\n\n\n\n2014\n32,996,182\n7.02\n10,515,057\n14,740,244\n29,893,588\n20.78\n34,332,906\n13,520,629\n1,159,157\n137,157,763\n20.01\n548,401,114\nNA\n\n\n2015\n34,527,129\n7.20\n9,663,164\n15,031,407\n31,568,620\n21.34\n33,810,533\n14,495,603\n1,208,690\n140,305,146\n20.08\n558,316,669\n1.81\n\n\n2016\n37,558,214\n7.62\n9,287,428\n15,268,526\n31,180,264\n20.49\n33,660,485\n14,817,154\n1,096,444\n142,868,515\n19.94\n573,607,853\n2.74\n\n\n2017\n46,673,871\n9.22\n9,407,284\n17,462,760\n32,018,808\n20.25\n34,672,097\n15,623,217\n1,059,448\n156,917,485\n21.42\n575,774,142\n0.38\n\n\n2018\n51,373,340\n9.63\n10,193,385\n17,863,570\n31,642,727\n19.43\n35,249,532\n16,019,546\n1,075,751\n163,417,851\n21.46\n598,103,526\n3.88\n\n\n2019\n53,811,966\n9.62\n10,486,576\n18,326,137\n31,212,577\n18.49\n35,593,000\n17,848,170\n1,070,505\n168,348,931\n21.25\n624,002,295\n4.33\n\n\n2020\n52,738,391\n9.44\n9,383,158\n18,754,058\n31,925,351\n18.16\n34,894,932\n20,412,225\n1,173,984\n169,282,099\n21.00\n636,792,368\n2.05\n\n\n2021\n57,807,221\n9.72\n9,953,689\n19,456,911\n32,233,771\n17.85\n35,216,206\n21,437,603\n1,109,425\n177,214,826\n20.92\n669,774,841\n5.18\n\n\n2022\n61,446,316\n9.61\n12,921,131\n19,888,239\n34,528,157\n18.46\n36,329,798\n22,238,701\n1,100,596\n188,452,938\n21.02\n708,271,407\n5.75"
  },
  {
    "objectID": "verotus.html#kiinteistövero",
    "href": "verotus.html#kiinteistövero",
    "title": "Verotus",
    "section": "Kiinteistövero",
    "text": "Kiinteistövero\nKunnan alueella sijaitsevista kiinteistöistä maksuunpantu kiinteistövero tilitetään kokonaisuudessaan kyseiselle kunnalle. Tilaston avulla voi arvioida kunnan kiinteistöverotuottojen suuruutta. Tilastoluvut eivät kuitenkaan kerro aivan tarkasti kunnille todellisuudessa tilitetyistä kiinteistöverotuotoista, koska maksuunpannun kiinteistöveron määrä voi muuttua muutosverotuksen myötä ja nämä muutokset eivät päivity tilastolukuihin. Lisäksi maksuunpantua kiinteistöveroa ei välttämättä saada kokonaisuudessaan kerättyä. Lähde: (Vero.fi 2024b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\nLukumäärä\nMuutos %\n\n\n\n\n2014\n21,358,866\n33301\nNA\n\n\n2015\n22,616,775\n35472\n5.89\n\n\n2016\n22,810,128\n35562\n0.85\n\n\n2017\n23,373,875\n35668\n2.47\n\n\n2018\n24,795,440\n35809\n6.08\n\n\n2019\n25,390,609\n35859\n2.40\n\n\n2020\n25,280,682\n36005\n-0.43\n\n\n2021\n24,715,854\n36082\n-2.23\n\n\n2022\n25,650,814\n36180\n3.78\n\n\n2023\n27,893,032\n36094\n8.74\n\n\n2024\n29,335,217\n36004\n5.17\n\n\n\n\n\n\n\n\nKiinteistöverojen kehitys\nKiinteistöverojen määrä oli vuonna 2024 yhteensä 29,335,217. Muutos edelliseen vuoteen 2023 oli 5.17."
  },
  {
    "objectID": "tyollisyys.html",
    "href": "tyollisyys.html",
    "title": "Työllisyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "tyollisyys.html#työttömien-työnhakijoiden--osuus-työvoimasta-koko-maassa-1",
    "href": "tyollisyys.html#työttömien-työnhakijoiden--osuus-työvoimasta-koko-maassa-1",
    "title": "Työllisyys",
    "section": "Työttömien työnhakijoiden %-osuus työvoimasta koko maassa",
    "text": "Työttömien työnhakijoiden %-osuus työvoimasta koko maassa\n\n\n\n\n\n\n\n\nSija\nMaakunta\nKunta\n2024M11\n\n\n\n\n1\nPohjanmaa\nLuoto\n2.4\n\n\n2\nAhvenanmaa\nBrändö\n2.7\n\n\n3\nAhvenanmaa\nFöglö\n2.7\n\n\n4\nPohjanmaa\nPedersören kunta\n2.9\n\n\n5\nAhvenanmaa\nSaltvik\n3.0\n\n\n6\nAhvenanmaa\nJomala\n3.1\n\n\n7\nPohjanmaa\nMaalahti\n3.2\n\n\n8\nAhvenanmaa\nLemland\n3.6\n\n\n9\nPohjanmaa\nMustasaari\n3.6\n\n\n10\nKeski-Pohjanmaa\nLestijärvi\n3.8\n\n\n11\nEtelä-Pohjanmaa\nEvijärvi\n3.9\n\n\n12\nPohjanmaa\nNärpiö\n4.0\n\n\n13\nAhvenanmaa\nGeta\n4.1\n\n\n14\nAhvenanmaa\nFinström\n4.4\n\n\n15\nEtelä-Pohjanmaa\nKuortane\n4.6\n\n\n16\nAhvenanmaa\nEckerö\n4.7\n\n\n17\nVarsinais-Suomi\nRusko\n4.7\n\n\n18\nVarsinais-Suomi\nMasku\n4.9\n\n\n19\nUusimaa\nInkoo\n5.0\n\n\n20\nPohjanmaa\nKruunupyy\n5.1\n\n\n21\nAhvenanmaa\nSund\n5.1\n\n\n22\nPohjanmaa\nUusikaarlepyy\n5.1\n\n\n23\nAhvenanmaa\nHammarland\n5.2\n\n\n24\nAhvenanmaa\nVårdö\n5.3\n\n\n25\nLappi\nUtsjoki\n5.4\n\n\n26\nPohjanmaa\nKorsnäs\n5.6\n\n\n27\nVarsinais-Suomi\nParainen\n5.6\n\n\n28\nVarsinais-Suomi\nNousiainen\n5.7\n\n\n29\nLappi\nSodankylä\n5.7\n\n\n30\nKeski-Pohjanmaa\nVeteli\n5.7\n\n\n31\nUusimaa\nSiuntio\n5.8\n\n\n32\nEtelä-Pohjanmaa\nIlmajoki\n5.9\n\n\n33\nEtelä-Pohjanmaa\nIsojoki\n5.9\n\n\n34\nPohjanmaa\nVöyri\n5.9\n\n\n35\nPohjanmaa\nKristiinankaupunki\n6.0\n\n\n36\nPohjanmaa\nLaihia\n6.0\n\n\n37\nVarsinais-Suomi\nLieto\n6.0\n\n\n38\nPohjois-Pohjanmaa\nMerijärvi\n6.0\n\n\n39\nVarsinais-Suomi\nPaimio\n6.1\n\n\n40\nEtelä-Pohjanmaa\nSoini\n6.1\n\n\n41\nPohjois-Pohjanmaa\nLiminka\n6.4\n\n\n42\nEtelä-Pohjanmaa\nAlajärvi\n6.5\n\n\n43\nKeski-Pohjanmaa\nKaustinen\n6.5\n\n\n44\nPirkanmaa\nKihniö\n6.5\n\n\n45\nEtelä-Pohjanmaa\nLappajärvi\n6.5\n\n\n46\nEtelä-Pohjanmaa\nVimpeli\n6.5\n\n\n47\nEtelä-Pohjanmaa\nKauhava\n6.6\n\n\n48\nEtelä-Pohjanmaa\nIsokyrö\n6.7\n\n\n49\nVarsinais-Suomi\nKaarina\n6.7\n\n\n50\nLappi\nKittilä\n6.7\n\n\n\n\n\n\n\n\nVertailu koko maan ja maakunnan osalta\nPori on sijalla 271, tarkasteltaessa työttömien työnhakijoiden %-osuutta työvoimasta. Viimeisin ennakkotietolukema on 12.9. Maakuntavertailussa (Satakunta) Pori on sijalla 16."
  },
  {
    "objectID": "tyollisyys.html#työttömät-työnhakijat",
    "href": "tyollisyys.html#työttömät-työnhakijat",
    "title": "Työllisyys",
    "section": "Työttömät työnhakijat",
    "text": "Työttömät työnhakijat\n\nTyöttömät työnhakijat laskentapäivänä\n\n\n\n\n\n\nTilastokeskuksen työssäkäyntitilaston mukaan työttömiä työnhakijoita oli 2024M11 yhteensä 4953 (lukema 2024M10: 4887).\n\n\n\n\n\n\n\n\nKuukausi\nTyöttömät työnhakijat laskentapäivänä (lkm.)\n\n\n\n\n2022M12\n4659\n\n\n2023M01\n4543\n\n\n2023M02\n4491\n\n\n2023M03\n4381\n\n\n2023M04\n4220\n\n\n2023M05\n4027\n\n\n2023M06\n4422\n\n\n2023M07\n4617\n\n\n2023M08\n4141\n\n\n2023M09\n4216\n\n\n2023M10\n4312\n\n\n2023M11\n4450\n\n\n2023M12\n5086\n\n\n2024M01\n4991\n\n\n2024M02\n4977\n\n\n2024M03\n4799\n\n\n2024M04\n4554\n\n\n2024M05\n4379\n\n\n2024M06\n4810\n\n\n2024M07\n4991\n\n\n2024M08\n4630\n\n\n2024M09\n4687\n\n\n2024M10\n4887\n\n\n2024M11\n4953"
  },
  {
    "objectID": "tyollisyys.html#alle-25-v.-työttömät-työnhakijat",
    "href": "tyollisyys.html#alle-25-v.-työttömät-työnhakijat",
    "title": "Työllisyys",
    "section": "Alle 25-v. työttömät työnhakijat",
    "text": "Alle 25-v. työttömät työnhakijat\n\n\n\n\n\n\n:::\n\nAlle 25-v. työttömät työnhakijat (lkm.)\nAlle 25-vuotiaita työttömiä oli 2024M11 yhteensä 688 (lukema 2024M10: 660).\n\n\n\n\n\n\n\n\nKuukausi\nAlle 25-v. työttömät työnhakijat (lkm.)\n\n\n\n\n2022M12\n637\n\n\n2023M01\n613\n\n\n2023M02\n614\n\n\n2023M03\n599\n\n\n2023M04\n577\n\n\n2023M05\n541\n\n\n2023M06\n643\n\n\n2023M07\n641\n\n\n2023M08\n554\n\n\n2023M09\n571\n\n\n2023M10\n606\n\n\n2023M11\n603\n\n\n2023M12\n728\n\n\n2024M01\n700\n\n\n2024M02\n703\n\n\n2024M03\n665\n\n\n2024M04\n635\n\n\n2024M05\n580\n\n\n2024M06\n694\n\n\n2024M07\n726\n\n\n2024M08\n605\n\n\n2024M09\n633\n\n\n2024M10\n660\n\n\n2024M11\n688"
  },
  {
    "objectID": "muuttoliike.html",
    "href": "muuttoliike.html",
    "title": "Muuttoliike",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\n\n\n\n\n\n\n\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}\n\n\n\n\n\n\n\nMuuttoliike\n\n\nKuntien välinen muuttoliike\nYmpyrä kuvaa kuntien välistä muuttoliikettä. Vihreällä olevat kunnat ovat muuttovoittajien ja punaisella olevat häviäjiä. Siniset viivat ympyrän keskellä kuvaavat muuttovirtojen suuruutta. Voit zoomata ympyrää hiiren rullalla. Laittamalla hiiren osoitin kuvan päälle näet muuttojen suuruudet ja liikesuunnat.\n\ndata = (await FileAttachmentDynamic(migrationChordCSV).csv());\n\n\nchart_chord_d3(data, title_txt_chord,chart_width,chart_height)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_chord_d3(data, title_txt_chord,chart_width,chart_height)), title_txt_chord, \"Save as SVG\")"
  },
  {
    "objectID": "liikenne.html",
    "href": "liikenne.html",
    "title": "Liikenne",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "liikenne.html#liikennemäärät",
    "href": "liikenne.html#liikennemäärät",
    "title": "Liikenne",
    "section": "Liikennemäärät",
    "text": "Liikennemäärät\n\nKartta LAM-antureista\nFintraffic kerää tietoa tieliikenteestä liikenteen automaattisten mittausasemien (LAM) avulla. Klikkaamalla kartan nuppineulaa saat auki lähimpien LAM-anturien tiedot alueellasi. Mittausajankohtia verrataan neljän vuoden ajalta samaan päivämäärään (2024-01-04) Lähde: (Fintraffic.fi 2024)\n\n\n\n\n\n\n\n\nLiikennemäärä yhteensä\nLiikennettä oli ajanjaksolla 2024-01-04 suunnassa vt8 Pori -&gt; Vaasa yhteensä 5935. Vastaavasti suunnassa vt8 Pori -&gt; Turku yhteensä 6017.\n\n\n\n\n\n\n\n\nHenkilö- tai pakettiauto\nHenkilö- tai pakettiautoliikennettä oli suunnassa vt8 Pori -&gt; Vaasa yhteensä 5255. Suunnan vt8 Pori -&gt; Turku liikennemäärä oli yhteensä 5345.\n\n\n\n\n\n\n\n\nKuorma-autot\nKuorma-autojen liikennemäärä oli suunnassa vt8 Pori -&gt; Vaasa yhteensä 617. Suunnan vt8 Pori -&gt; Turku kuorma-automäärä oli yhteensä 603.\n\n\n\n\n\n\n\n\nLinja-autot\nLinja-autoja liikkui suunnassa vt8 Pori -&gt; Vaasa yhteensä 13. Vastaavasti suunnassa vt8 Pori -&gt; Turku linja-autoja oli yhteensä 12.\n\n\n\n\n\n\n\n\nHenkilöauto ja asuntovaunu\nAsuntovaunujen kanssa liikkuvia henkilöautoja oli suunnassa vt8 Pori -&gt; Vaasa yhteensä 17 ja suunnassa vt8 Pori -&gt; Turku yhteensä 12.\n\n\n\n\n\n\n\n\nMoottoripyörät ja mopot\n\n\nHCT (High Capacity Truck)\nLyhenne HCT tulee sanoista High Capacity Transport. Lyhenne on kansainvälisesti vakiintunut termi sallittua pidemmille tai raskaammille yhdistelmille tieliikenteessä, joita ei kuitenkaan pidetä erikoiskuljetuksina."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Alkusanat",
    "section": "",
    "text": "Alkusanat\nKuukausiraportti tarjoaa tietoa väestöstä, työmarkkinoista, asumisesta, rakentamisesta ja taloudesta kuukausi tai neljännesvuositasolla. Tietolähteinä käytetään esimerkiksi Tilastokeskuksen ja Verohallinon tilastoaineistoa. Kuukausiraporttia kehitetään yhteistyössä kuntien kanssa.\nRaportti on ajettu tammikuussa, 2025\nRaportti on julkaistu (GNU.org 2024) lisenssin alla. Kuukausiraportti on html-muodossa. Malleja kuntakohtaisesta raporteista löytyy osoitteista:\n\nKangasala: https://kangasalakehitys.github.io/kuukausiraportti/\nAkaa: https://kangasalakehitys.github.io/akaa/\nJuupajoki: https://kangasalakehitys.github.io/juupajoki/\nKuhmoinen: https://kangasalakehitys.github.io/kuhmoinen/\nMasku: https://kangasalakehitys.github.io/masku/\nNousinen: https://kangasalakehitys.github.io/nousiainen/\nPälkäne: https://kangasalakehitys.github.io/palkane/\nParkano: https://kangasalakehitys.github.io/parkano/\nUrjala: https://kangasalakehitys.github.io/urjala/\nYlöjärvi: https://kangasalakehitys.github.io/ylojarvi/\n\n\n\n\n\n\nLähteet\n\nGNU.org. 2024. LGPL 2.1 lisenssi. GNU.org. https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html."
  },
  {
    "objectID": "asuminen.html",
    "href": "asuminen.html",
    "title": "Asuminen",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "asuminen.html#asuminen---asuntokunnat-talotyypeittäin",
    "href": "asuminen.html#asuminen---asuntokunnat-talotyypeittäin",
    "title": "Asuminen",
    "section": "Asuminen - Asuntokunnat talotyypeittäin",
    "text": "Asuminen - Asuntokunnat talotyypeittäin\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosineljännes\nYhteensä\nOmakoti- ja paritalot\nRivitalot\nKerrostalot\nMuut rakennukset\n\n\n\n\n2023Q4\n44907\n18717\n5487\n19902\n801\n\n\n2024Q1*\n44878\n18708\n5489\n19986\n695\n\n\n2024Q2*\n44828\n18695\n5511\n19927\n695\n\n\n2024Q3*\n44969\n18669\n5526\n20082\n692\n\n\n\n\n\n\n\n\nTalotyyppien %-osuudet asuntokunnissa\nAsuntokunnista 2024Q3* omakoti- ja paritaloissa asui 41.5 % (edell. 41.7). Rivitaloissa asuvien osuus oli 12.3% (edell. 12.3) ja kerrostaloissa 44.7% (edell. 44.5)."
  },
  {
    "objectID": "asuminen.html#asuminen---asuntokunnat-talotyypin-ja-koon-mukaan",
    "href": "asuminen.html#asuminen---asuntokunnat-talotyypin-ja-koon-mukaan",
    "title": "Asuminen",
    "section": "Asuminen - Asuntokunnat talotyypin ja koon mukaan",
    "text": "Asuminen - Asuntokunnat talotyypin ja koon mukaan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosineljännes\nAsuntokunnan koko\nYhteensä\nOmakoti- ja paritalot\nRivitalot\nKerrostalot\nMuut rakennukset\n\n\n\n\n2023Q4\n1 henkilö\n22774\n4968\n2955\n14297\n554\n\n\n2023Q4\n2 henkilöä\n14002\n7688\n1765\n4385\n164\n\n\n2023Q4\n3 henkilöä\n3884\n2652\n472\n724\n36\n\n\n2023Q4\n4 henkilöä tai enemmän\n4247\n3409\n295\n496\n47\n\n\n2024Q1*\n1 henkilö\n22742\n4958\n2962\n14352\n470\n\n\n2024Q1*\n2 henkilöä\n13962\n7687\n1761\n4364\n150\n\n\n2024Q1*\n3 henkilöä\n3929\n2659\n470\n770\n30\n\n\n2024Q1*\n4 henkilöä tai enemmän\n4245\n3404\n296\n500\n45\n\n\n2024Q2*\n1 henkilö\n22662\n4949\n2988\n14264\n461\n\n\n2024Q2*\n2 henkilöä\n13942\n7626\n1755\n4403\n158\n\n\n2024Q2*\n3 henkilöä\n3996\n2714\n478\n770\n34\n\n\n2024Q2*\n4 henkilöä tai enemmän\n4228\n3406\n290\n490\n42\n\n\n2024Q3*\n1 henkilö\n22810\n4984\n3002\n14365\n459\n\n\n2024Q3*\n2 henkilöä\n13967\n7625\n1753\n4434\n155\n\n\n2024Q3*\n3 henkilöä\n3995\n2687\n475\n797\n36\n\n\n2024Q3*\n4 henkilöä tai enemmän\n4197\n3373\n296\n486\n42"
  },
  {
    "objectID": "aluetalous.html",
    "href": "aluetalous.html",
    "title": "Aluetalous ja yritystoiminta",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "aluetalous.html#aloittaneet-ja-lopettaneet-yritykset",
    "href": "aluetalous.html#aloittaneet-ja-lopettaneet-yritykset",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Aloittaneet ja lopettaneet yritykset",
    "text": "Aloittaneet ja lopettaneet yritykset\n\n\n\n\n\n\n\nAloittaneet ja lopettaneet yritykset\nAloittaneita yrityksiä ajanjaksolla 2024Q2 oli yhteensä 124 (lukema 2024Q1: 148). . Lopettaneiden yritysten määrä oli samalla ajanjaksolla yhteensä 102 (lukema 2024Q1: 153)..\n\n\n\n\n\n\n\n\nVuosineljännes\nAloittaneet yritykset (lkm)\nLopettaneet yritykset (lkm)\n\n\n\n\n2018Q3\n89\n65\n\n\n2018Q4\n110\n105\n\n\n2019Q1\n141\n67\n\n\n2019Q2\n95\n63\n\n\n2019Q3\n135\n45\n\n\n2019Q4\n118\n79\n\n\n2020Q1\n154\n116\n\n\n2020Q2\n99\n65\n\n\n2020Q3\n129\n61\n\n\n2020Q4\n107\n101\n\n\n2021Q1\n149\n95\n\n\n2021Q2\n121\n77\n\n\n2021Q3\n104\n66\n\n\n2021Q4\n101\n98\n\n\n2022Q1\n149\n136\n\n\n2022Q2\n124\n60\n\n\n2022Q3\n110\n58\n\n\n2022Q4\n107\n116\n\n\n2023Q1\n132\n144\n\n\n2023Q2\n118\n105\n\n\n2023Q3\n113\n69\n\n\n2023Q4\n121\n111\n\n\n2024Q1\n148\n153\n\n\n2024Q2\n124\n102"
  },
  {
    "objectID": "aluetalous.html#avoimet-työpaikat-kuukauden-laskentapäivänä-lkm.",
    "href": "aluetalous.html#avoimet-työpaikat-kuukauden-laskentapäivänä-lkm.",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Avoimet työpaikat kuukauden laskentapäivänä (lkm.)",
    "text": "Avoimet työpaikat kuukauden laskentapäivänä (lkm.)\n\n\n\n\n\n\n\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\nAvoimia työpaikkoja oli 2024M11 yhteensä 274 (lukema 2024M10: 346).\n\n\n\n\n\n\n\n\nKuukausi\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\n\n\n\n\n2022M12\n681\n\n\n2023M01\n1915\n\n\n2023M02\n1391\n\n\n2023M03\n1231\n\n\n2023M04\n1049\n\n\n2023M05\n956\n\n\n2023M06\n745\n\n\n2023M07\n640\n\n\n2023M08\n604\n\n\n2023M09\n474\n\n\n2023M10\n443\n\n\n2023M11\n350\n\n\n2023M12\n502\n\n\n2024M01\n1673\n\n\n2024M02\n950\n\n\n2024M03\n750\n\n\n2024M04\n627\n\n\n2024M05\n455\n\n\n2024M06\n238\n\n\n2024M07\n241\n\n\n2024M08\n265\n\n\n2024M09\n266\n\n\n2024M10\n346\n\n\n2024M11\n274"
  },
  {
    "objectID": "aluetalous.html#uudet-avoimet-työpaikat",
    "href": "aluetalous.html#uudet-avoimet-työpaikat",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Uudet avoimet työpaikat",
    "text": "Uudet avoimet työpaikat\n\n\n\n\n\n\n\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\nAvoimia työpaikkoja oli 2024M11 yhteensä 249 (lukema 2024M10: 363).\n\n\n\n\n\n\n\n\nKuukausi\nUudet avoimet työpaikat kuukauden aikana (lkm.)\n\n\n\n\n2022M12\n811\n\n\n2023M01\n2612\n\n\n2023M02\n1029\n\n\n2023M03\n1196\n\n\n2023M04\n834\n\n\n2023M05\n1052\n\n\n2023M06\n799\n\n\n2023M07\n649\n\n\n2023M08\n766\n\n\n2023M09\n626\n\n\n2023M10\n584\n\n\n2023M11\n514\n\n\n2023M12\n474\n\n\n2024M01\n1720\n\n\n2024M02\n934\n\n\n2024M03\n670\n\n\n2024M04\n561\n\n\n2024M05\n476\n\n\n2024M06\n187\n\n\n2024M07\n216\n\n\n2024M08\n285\n\n\n2024M09\n298\n\n\n2024M10\n363\n\n\n2024M11\n249"
  },
  {
    "objectID": "data/kunta_center.html",
    "href": "data/kunta_center.html",
    "title": "",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’&gt;     \n\n\n                 0 0     false"
  },
  {
    "objectID": "kansainvalisyys.html",
    "href": "kansainvalisyys.html",
    "title": "Kansainvälisyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "kansainvalisyys.html#kansainvälisyys---maahanmuutto-ja-nettomaahanmuutto",
    "href": "kansainvalisyys.html#kansainvälisyys---maahanmuutto-ja-nettomaahanmuutto",
    "title": "Kansainvälisyys",
    "section": "Kansainvälisyys - Maahanmuutto ja nettomaahanmuutto",
    "text": "Kansainvälisyys - Maahanmuutto ja nettomaahanmuutto\n\n\n\n\n\n\n\nMaahanmuutto ja nettomaahanmuutto\nKumulatiivinen nettomaahanmuutto oli vuoden alusta tähän hetkeen 2024M11* yhteensä 613. Edellisvuoden lukema nettomaahanmuutossa oli 709. Erotusta nettomaahanmuutossa viime vuoteen on yhteensä -96 henkilöä. Pohjoismaista oli muuttanut yhteensä yhteensä 24 henkilöä ja muista EU-maista 83 henkilöä. Kokonaisuudessaan maahanmuuttajia oli yhteensä 735.\nNettomaahanmuutto (tai nettosiirtolaisuus) on maahanmuuton ja maastamuuton erotus. Lähde: Tilastokeskus\n\n\n\n\n\n\n\n\nVuosi\nMaahanmuutto Suomeen\nMaahanmuutto Suomeen Pohjoismaista\nMaahanmuutto Suomeen EU-maista\nNettomaahanmuutto\n\n\n\n\n2015\n232\n17\n119\n85\n\n\n2016\n332\n38\n130\n192\n\n\n2017\n333\n21\n93\n212\n\n\n2018\n311\n16\n99\n188\n\n\n2019\n266\n24\n104\n138\n\n\n2020\n316\n32\n150\n208\n\n\n2021\n374\n23\n134\n224\n\n\n2022\n543\n22\n132\n399\n\n\n2023\n843\n25\n109\n709\n\n\n2024M11*\n735\n24\n83\n613"
  },
  {
    "objectID": "maps/pienalue2024.html",
    "href": "maps/pienalue2024.html",
    "title": "",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’&gt;  Tilastollinen_aluejako_2021_alkaen  FIN dataset\n\nTilastollinen_aluejako_2021_alkaen\n\n               PROJCRS[“ETRS89 / GK24FIN”,BASEGEOGCRS[“ETRS89”,ENSEMBLE[“European Terrestrial Reference System 1989 ensemble”,MEMBER[“European Terrestrial Reference Frame 1989”],MEMBER[“European Terrestrial Reference Frame 1990”],MEMBER[“European Terrestrial Reference Frame 1991”],MEMBER[“European Terrestrial Reference Frame 1992”],MEMBER[“European Terrestrial Reference Frame 1993”],MEMBER[“European Terrestrial Reference Frame 1994”],MEMBER[“European Terrestrial Reference Frame 1996”],MEMBER[“European Terrestrial Reference Frame 1997”],MEMBER[“European Terrestrial Reference Frame 2000”],MEMBER[“European Terrestrial Reference Frame 2005”],MEMBER[“European Terrestrial Reference Frame 2014”],ELLIPSOID[“GRS 1980”,6378137,298.257222101,LENGTHUNIT[“metre”,1]],ENSEMBLEACCURACY[0.1]],PRIMEM[“Greenwich”,0,ANGLEUNIT[“degree”,0.0174532925199433]],ID[“EPSG”,4258]],CONVERSION[“Finland Gauss-Kruger zone 24”,METHOD[“Transverse Mercator”,ID[“EPSG”,9807]],PARAMETER[“Latitude of natural origin”,0,ANGLEUNIT[“degree”,0.0174532925199433],ID[“EPSG”,8801]],PARAMETER[“Longitude of natural origin”,24,ANGLEUNIT[“degree”,0.0174532925199433],ID[“EPSG”,8802]],PARAMETER[“Scale factor at natural origin”,1,SCALEUNIT[“unity”,1],ID[“EPSG”,8805]],PARAMETER[“False easting”,24500000,LENGTHUNIT[“metre”,1],ID[“EPSG”,8806]],PARAMETER[“False northing”,0,LENGTHUNIT[“metre”,1],ID[“EPSG”,8807]]],CS[Cartesian,2],AXIS[“northing (N)”,north,ORDER[1],LENGTHUNIT[“metre”,1]],AXIS[“easting (E)”,east,ORDER[2],LENGTHUNIT[“metre”,1]],USAGE[SCOPE[“Cadastre, engineering survey, topographic mapping (large scale).”],AREA[“Finland - nominally onshore between 23�30’E and 24�30’E but may be used in adjacent areas if a municipality chooses to use one zone over its whole extent.”],BBOX[59.86,23.5,68.84,24.5]],ID[“EPSG”,3878]] +proj=tmerc +lat_0=0 +lon_0=24 +k=1 +x_0=24500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 27312 3878 EPSG:3878 ETRS89 / GK24FIN tmerc EPSG:7019 false"
  },
  {
    "objectID": "syntyvyys.html",
    "href": "syntyvyys.html",
    "title": "Syntyvyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "syntyvyys.html#luonnollinen-väestönkasvu",
    "href": "syntyvyys.html#luonnollinen-väestönkasvu",
    "title": "Syntyvyys",
    "section": "Luonnollinen väestönkasvu",
    "text": "Luonnollinen väestönkasvu\n\nLuonnollinen väestönlisäys\n\n\n\n\n\n\nSyntyneiden enemmyys eli luonnollinen väestönlisäys tarkoittaa elävänä syntyneiden ja kuolleiden erotusta.\nLuonnollinen väestönlisäys ajanjaksolla 2024Q2* - 2024Q3* oli yhteensä -355 (2024Q2*: -127). Vuosina 2022 ja 2023 luonnollinen väestönlisäys oli 2022: -630 ja 2023: -619\n\n\n\n\n\n\n\n\nVuosi\nEnnakkotieto\n\n\n\n\n2012\nNA\n\n\n2013\nNA\n\n\n2014\nNA\n\n\n2015\nNA\n\n\n2016\nNA\n\n\n2017\nNA\n\n\n2018\nNA\n\n\n2019\nNA\n\n\n2020\nNA\n\n\n2021\nNA\n\n\n2022\nNA\n\n\n2023\nNA\n\n\n2024Q1*\n-130\n\n\n2024Q2*\n-127\n\n\n2024Q3*\n-98"
  },
  {
    "objectID": "syntyvyys.html#syntyneet",
    "href": "syntyvyys.html#syntyneet",
    "title": "Syntyvyys",
    "section": "Syntyneet",
    "text": "Syntyneet\n\nSyntyvyys\n\n\n\n\n\n\n\n\nSyntyvyys\nSyntyvyys ajanjaksolla 2024Q2* - 2024Q3* oli yhteensä 452 (lukema 2024Q2* oli 138). Vuosina 2022 ja 2023 syntyvyys oli lukemissa (2022) 591 ja (2023) 590.\n\n\n\n\n\n\n\n\nVuosi\nEnnakkotieto\n\n\n\n\n2012\nNA\n\n\n2013\nNA\n\n\n2014\nNA\n\n\n2015\nNA\n\n\n2016\nNA\n\n\n2017\nNA\n\n\n2018\nNA\n\n\n2019\nNA\n\n\n2020\nNA\n\n\n2021\nNA\n\n\n2022\nNA\n\n\n2023\nNA\n\n\n2024Q1*\n145\n\n\n2024Q2*\n138\n\n\n2024Q3*\n169"
  },
  {
    "objectID": "syntyvyys.html#väestönmuutokset---väestöpyramidi",
    "href": "syntyvyys.html#väestönmuutokset---väestöpyramidi",
    "title": "Syntyvyys",
    "section": "Väestönmuutokset - Väestöpyramidi",
    "text": "Väestönmuutokset - Väestöpyramidi\n\nDOM.download(() =&gt; serialize(pyramid), \"Väestöpyramidi\", \"Save as SVG\")\n\n\n\n\n\n\n\npyramid_pop_data = FileAttachmentDynamic(pyramid_pop_csv).csv({typed: true})\n\ntranslations = ({\n  v1990: \"1990\",\n  v2010: \"2010\",\n  v2024: valitut_kk_tahti\n  })\n\npyramid = toSVG(Plot.plot({\n  width: 600,\n  height: 600,\n  marginTop: 20,\n  marginRight: 20,\n  marginBottom: 30,\n  marginLeft: 40,\n  x: {\n    label: \"← mies · väestö · nainen →\",\n    labelAnchor: \"center\",\n    tickFormat: Math.abs,\n    //domain: [-300, 300]\n  },\n  y: {grid: true},\n  color: {\n    width: 300,\n    domain: [\"v1990\", \"v2010\", \"v2024\"],\n    range: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\"],\n    legend: true,\n    className: 'large-font',\n    tickFormat: (d) =&gt; translations[d]\n  },\n  style: {\n    fontSize: 14\n  },\n  marks: [\n    Plot.lineX(pyramid_pop_data, {\n      x: (d) =&gt; d.population * (d.sex === \"Miehet\" ? -1 : 1),\n      y: \"age\",\n      z: (d) =&gt; [d.sex, d.category].join(\",\"),\n      stroke: \"category\",\n      strokeWidth: 4,\n      fill: \"category\",\n      fillOpacity: 0\n    }),\n    Plot.ruleX([0]),\n    Plot.ruleY([0])\n  ]\n}))"
  },
  {
    "objectID": "vaesto.html",
    "href": "vaesto.html",
    "title": "Väestönmuutokset",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "vaesto.html#kuntien-välinen-nettomuutto---viimeiset-12kk",
    "href": "vaesto.html#kuntien-välinen-nettomuutto---viimeiset-12kk",
    "title": "Väestönmuutokset",
    "section": "Kuntien välinen nettomuutto - viimeiset 12kk",
    "text": "Kuntien välinen nettomuutto - viimeiset 12kk\nVoit tarkistella karttaa tarkemmin pyörittämällä hiiren rullanäppäintä.\n\ndata_migr = (await FileAttachmentDynamic(migrBetwMuniMapCSV).csv()).map((d) =&gt; (d.muutos = +d.muutos, d))\n\n//Väritetään kartta\nmapInterpolateRdBu_migr = d3.scaleDiverging([-150, 0, 150], d3.interpolatePiYG);\n\nborderColorDark_migr = \"#525252\";\n\n//Piirretään kartta\nchart_map_d3(data_migr, mapTopoJSON, mapInterpolateRdBu_migr, borderColorDark_migr, title_txt_map_migr,chart_width_migr,chart_height_migr)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_map_d3(data_migr, mapTopoJSON, mapInterpolateRdBu_migr, borderColorDark_migr, title_txt_map_migr,chart_width_migr,chart_height_migr)), title_txt_map_migr, \"Save as SVG\")\n\n\n\n\n\n\n\n\n\nKuntien välinen nettomuutto - viimeiset 12kk\n\n\n\n\n\n\n\n\nSija\nMaakunta\nKunta\nKuntien välinen nettomuutto\n\n\n\n\n1\nUusimaa\nHelsinki\n2689\n\n\n2\nPirkanmaa\nTampere\n2580\n\n\n3\nUusimaa\nEspoo\n1886\n\n\n4\nVarsinais-Suomi\nTurku\n1825\n\n\n5\nUusimaa\nTuusula\n933\n\n\n6\nPirkanmaa\nNokia\n491\n\n\n7\nPirkanmaa\nKangasala\n440\n\n\n8\nPohjois-Savo\nKuopio\n416\n\n\n9\nPirkanmaa\nPirkkala\n203\n\n\n10\nUusimaa\nLohja\n187\n\n\n11\nUusimaa\nSipoo\n184\n\n\n12\nUusimaa\nKirkkonummi\n155\n\n\n13\nVarsinais-Suomi\nNaantali\n137\n\n\n14\nVarsinais-Suomi\nKaarina\n118\n\n\n15\nSatakunta\nPori\n87\n\n\n16\nLappi\nInari\n75\n\n\n17\nAhvenanmaa\nJomala\n67\n\n\n18\nPirkanmaa\nHämeenkyrö\n66\n\n\n19\nPirkanmaa\nOrivesi\n57\n\n\n20\nPohjois-Pohjanmaa\nIi\n40\n\n\n21\nLappi\nSodankylä\n39\n\n\n22\nUusimaa\nSiuntio\n38\n\n\n23\nPohjois-Pohjanmaa\nOulu\n37\n\n\n24\nEtelä-Savo\nMäntyharju\n35\n\n\n25\nLappi\nKittilä\n33\n\n\n26\nPohjois-Pohjanmaa\nKempele\n32\n\n\n27\nUusimaa\nInkoo\n31\n\n\n28\nPäijät-Häme\nIitti\n30\n\n\n29\nPohjois-Karjala\nIlomantsi\n29\n\n\n30\nPirkanmaa\nAkaa\n28\n\n\n31\nPäijät-Häme\nHeinola\n27\n\n\n32\nKeski-Suomi\nMuurame\n27\n\n\n33\nPohjois-Pohjanmaa\nSiikalatva\n27\n\n\n34\nEtelä-Savo\nSulkava\n27\n\n\n35\nPohjois-Savo\nTuusniemi\n27\n\n\n36\nPäijät-Häme\nHollola\n26\n\n\n37\nEtelä-Pohjanmaa\nIlmajoki\n26\n\n\n38\nEtelä-Savo\nPuumala\n26\n\n\n39\nEtelä-Savo\nHirvensalmi\n25\n\n\n40\nVarsinais-Suomi\nKustavi\n24\n\n\n41\nUusimaa\nHyvinkää\n23\n\n\n42\nPirkanmaa\nVesilahti\n23\n\n\n43\nVarsinais-Suomi\nRaisio\n21\n\n\n44\nUusimaa\nHanko\n19\n\n\n45\nPohjois-Savo\nRautalampi\n19\n\n\n46\nPohjois-Savo\nRautavaara\n19\n\n\n47\nAhvenanmaa\nFinström\n18\n\n\n48\nKeski-Pohjanmaa\nKannus\n18\n\n\n49\nPohjois-Pohjanmaa\nPyhäjoki\n18\n\n\n50\nKeski-Pohjanmaa\nPerho\n17\n\n\n\n\n\n\n\n\n\nKuntien välinen nettomuutto - viimeiset 12kk, top20\nPori on sijalla 15, tarkasteltaessa kuntien välistä nettomuuttoa viimeisen 12kk aikana. Kuntien välinen nettomuuttolukema on 87. Maakuntavertailussa (Satakunta) Pori on sijalla 1."
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko",
    "href": "vaesto.html#väestönmuutokset---väestöennakko",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko",
    "text": "Väestönmuutokset - Väestöennakko\n\n\n\n\n\n\n\nEnnakkotiedot\nEnnakkotietojen (2024M11) perusteella väkiluku on laskenut -0.04 % (2024M10: -0.02 %). Uusin väestön ennakkotieto on 83335 (edell. lukema 83365). Vuoden alusta (2023: 83106) väkiluku on kasvanut 0.28 %.\n\n\n\n\n\n\n\n\nVuosi\nEnnakkotieto\n\n\n\n\n2020\nNA\n\n\n2021\nNA\n\n\n2022\nNA\n\n\n2023\nNA\n\n\n2024M01*\n83206\n\n\n2024M02*\n83235\n\n\n2024M03*\n83258\n\n\n2024M04*\n83264\n\n\n2024M05*\n83230\n\n\n2024M06*\n83260\n\n\n2024M07*\n83260\n\n\n2024M08*\n83360\n\n\n2024M09*\n83384\n\n\n2024M10*\n83365\n\n\n2024M11*\n83335"
  },
  {
    "objectID": "vaesto.html#väkiluvun-muutos--vuoden-2023-lopusta",
    "href": "vaesto.html#väkiluvun-muutos--vuoden-2023-lopusta",
    "title": "Väestönmuutokset",
    "section": "Väkiluvun muutos-% vuoden 2023 lopusta",
    "text": "Väkiluvun muutos-% vuoden 2023 lopusta\nVoit tarkistella kartaa lähemmin pyörittämällä hiiren rullanäppäintä.\n\ndata = (await FileAttachmentDynamic(populationMapCSV).csv()).map((d) =&gt; (d.muutos = +d.muutos, d))\n\n//Väritetään kartta\n//mapInterpolateRdBu = d3.scaleDiverging([domain_min, 0, domain_max], d3.interpolateRdBu);\nmapInterpolateRdBu = d3.scaleDiverging([-1.5, 0, 1.5], d3.interpolatePiYG);\n\nborderColorDark = \"#525252\";\n\n//Piirretään kartta\nchart_map_d3(data, mapTopoJSON, mapInterpolateRdBu, borderColorDark, title_txt_map,chart_width,chart_height)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_map_d3(data, mapTopoJSON, mapInterpolateRdBu, borderColorDark, title_txt_map,chart_width,chart_height)), title_txt_map, \"Save as SVG\")"
  },
  {
    "objectID": "vaesto.html#väkiluvun-muutos--edellisvuoden-lopusta",
    "href": "vaesto.html#väkiluvun-muutos--edellisvuoden-lopusta",
    "title": "Väestönmuutokset",
    "section": "Väkiluvun muutos-% edellisvuoden lopusta",
    "text": "Väkiluvun muutos-% edellisvuoden lopusta\n\n\n\n\n\n\n\n\nSija\nMaakunta\nKunta\nVäestö 31.12.\n2024M11*\nMuutos-%\n\n\n\n\n1\nPohjanmaa\nKaskinen\n1208\n1248\n3.31\n\n\n2\nUusimaa\nTuusula\n41338\n42226\n2.15\n\n\n3\nPohjanmaa\nVaasa\n68956\n70380\n2.07\n\n\n4\nVarsinais-Suomi\nTurku\n201863\n206010\n2.05\n\n\n5\nUusimaa\nEspoo\n314024\n320392\n2.03\n\n\n6\nPirkanmaa\nTampere\n255050\n260049\n1.96\n\n\n7\nUusimaa\nVantaa\n247443\n251244\n1.54\n\n\n8\nPirkanmaa\nNokia\n35647\n36141\n1.39\n\n\n9\nVarsinais-Suomi\nRaisio\n25331\n25682\n1.39\n\n\n10\nUusimaa\nHelsinki\n674500\n683605\n1.35\n\n\n11\nPirkanmaa\nKangasala\n33473\n33926\n1.35\n\n\n12\nPirkanmaa\nPirkkala\n20763\n21043\n1.35\n\n\n13\nPohjois-Savo\nKuopio\n124021\n125632\n1.30\n\n\n14\nAhvenanmaa\nJomala\n5697\n5769\n1.26\n\n\n15\nUusimaa\nKirkkonummi\n41154\n41656\n1.22\n\n\n16\nLappi\nInari\n7127\n7212\n1.19\n\n\n17\nAhvenanmaa\nEckerö\n942\n953\n1.17\n\n\n18\nKeski-Suomi\nJyväskylä\n147746\n149366\n1.10\n\n\n19\nUusimaa\nSipoo\n22595\n22837\n1.07\n\n\n20\nEtelä-Savo\nPieksämäki\n17050\n17219\n0.99\n\n\n21\nPohjois-Karjala\nJoensuu\n78062\n78744\n0.87\n\n\n22\nAhvenanmaa\nFinström\n2610\n2632\n0.84\n\n\n23\nUusimaa\nJärvenpää\n46490\n46881\n0.84\n\n\n24\nPirkanmaa\nVesilahti\n4469\n4506\n0.83\n\n\n25\nUusimaa\nPorvoo\n51289\n51704\n0.81\n\n\n26\nKeski-Suomi\nUurainen\n3615\n3644\n0.80\n\n\n27\nAhvenanmaa\nMaarianhamina - Mariehamn\n11812\n11900\n0.75\n\n\n28\nKeski-Suomi\nLuhanka\n702\n707\n0.71\n\n\n29\nPohjois-Pohjanmaa\nOulu\n214633\n216150\n0.71\n\n\n30\nPohjanmaa\nLuoto\n5843\n5882\n0.67\n\n\n31\nPirkanmaa\nValkeakoski\n20694\n20832\n0.67\n\n\n32\nKeski-Suomi\nLaukaa\n18762\n18886\n0.66\n\n\n33\nLappi\nRovaniemi\n65286\n65712\n0.65\n\n\n34\nKeski-Suomi\nJoutsa\n4079\n4105\n0.64\n\n\n35\nVarsinais-Suomi\nKaarina\n36339\n36567\n0.63\n\n\n36\nVarsinais-Suomi\nKustavi\n949\n955\n0.63\n\n\n37\nEtelä-Pohjanmaa\nSeinäjoki\n66160\n66580\n0.63\n\n\n38\nEtelä-Pohjanmaa\nIlmajoki\n12343\n12419\n0.62\n\n\n39\nSatakunta\nKankaanpää\n12394\n12471\n0.62\n\n\n40\nPäijät-Häme\nLahti\n120693\n121430\n0.61\n\n\n41\nPohjois-Karjala\nOutokumpu\n6409\n6448\n0.61\n\n\n42\nVarsinais-Suomi\nLaitila\n8441\n8492\n0.60\n\n\n43\nEtelä-Karjala\nLappeenranta\n72988\n73425\n0.60\n\n\n44\nAhvenanmaa\nGeta\n509\n512\n0.59\n\n\n45\nUusimaa\nSiuntio\n6158\n6194\n0.58\n\n\n46\nPirkanmaa\nLempäälä\n24711\n24846\n0.55\n\n\n47\nPohjois-Pohjanmaa\nKempele\n19514\n19619\n0.54\n\n\n48\nUusimaa\nKerava\n38211\n38417\n0.54\n\n\n49\nUusimaa\nNurmijärvi\n44785\n45029\n0.54\n\n\n50\nKanta-Häme\nRiihimäki\n28483\n28637\n0.54\n\n\n\n\n\n\n\n\nVäkiluvun muutos-% edellisvuoden lopusta\nPori on sijalla 70, tarkasteltaessa väkiluvun muutosta edellisvuoden lopusta kuntien kesken. Viimeisin ennakkotietolukema on 83335 (muutos-% edellisen vuoden loppuun: 0.28). Maakuntavertailussa (Satakunta) Pori on sijalla 3."
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko-viisi-ikäluokkaa",
    "href": "vaesto.html#väestönmuutokset---väestöennakko-viisi-ikäluokkaa",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko, viisi ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, viisi ikäluokkaa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\n0-6\n0-6 %\n7-15\n7-15 %\n16-64\n16-64 %\n65-79\n65-79 %\n80+\n80+ %\n\n\n\n\n2000\n84573\n6270\n7.41\n8669\n10.25\n55134\n65.19\n11262\n13.32\n3238\n3.83\n\n\n2001\n84439\n6059\n7.18\n8704\n10.31\n54867\n64.98\n11418\n13.52\n3391\n4.02\n\n\n2002\n84306\n5813\n6.90\n8774\n10.41\n54680\n64.86\n11604\n13.76\n3435\n4.07\n\n\n2003\n84561\n5748\n6.80\n8783\n10.39\n54696\n64.68\n11772\n13.92\n3562\n4.21\n\n\n2004\n84491\n5689\n6.73\n8670\n10.26\n54429\n64.42\n11979\n14.18\n3724\n4.41\n\n\n2005\n84455\n5728\n6.78\n8533\n10.10\n54269\n64.26\n12028\n14.24\n3897\n4.61\n\n\n2006\n84456\n5723\n6.78\n8333\n9.87\n54029\n63.97\n12307\n14.57\n4064\n4.81\n\n\n2007\n84523\n5780\n6.84\n8220\n9.73\n54019\n63.91\n12270\n14.52\n4234\n5.01\n\n\n2008\n84614\n5833\n6.89\n7982\n9.43\n53995\n63.81\n12379\n14.63\n4425\n5.23\n\n\n2009\n84844\n5897\n6.95\n7883\n9.29\n53926\n63.56\n12523\n14.76\n4615\n5.44\n\n\n2010\n85026\n5921\n6.96\n7759\n9.13\n53839\n63.32\n12709\n14.95\n4798\n5.64\n\n\n2011\n85078\n5896\n6.93\n7582\n8.91\n53560\n62.95\n13072\n15.36\n4968\n5.84\n\n\n2012\n85201\n5937\n6.97\n7475\n8.77\n53089\n62.31\n13615\n15.98\n5085\n5.97\n\n\n2013\n85399\n5924\n6.94\n7542\n8.83\n52588\n61.58\n14200\n16.63\n5145\n6.02\n\n\n2014\n85418\n5854\n6.85\n7569\n8.86\n52099\n60.99\n14693\n17.20\n5203\n6.09\n\n\n2015\n85363\n5783\n6.77\n7576\n8.88\n51558\n60.40\n15085\n17.67\n5361\n6.28\n\n\n2016\n85059\n5624\n6.61\n7571\n8.90\n51162\n60.15\n15260\n17.94\n5442\n6.40\n\n\n2017\n84587\n5430\n6.42\n7666\n9.06\n50380\n59.56\n15554\n18.39\n5557\n6.57\n\n\n2018\n84403\n5310\n6.29\n7736\n9.17\n49953\n59.18\n15743\n18.65\n5661\n6.71\n\n\n2019\n83934\n5076\n6.05\n7689\n9.16\n49467\n58.94\n15909\n18.95\n5793\n6.90\n\n\n2020\n83684\n4850\n5.80\n7705\n9.21\n49104\n58.68\n16114\n19.26\n5911\n7.06\n\n\n2021\n83482\n4739\n5.68\n7663\n9.18\n48830\n58.49\n16179\n19.38\n6071\n7.27\n\n\n2022\n83205\n4559\n5.48\n7581\n9.11\n48707\n58.54\n16407\n19.72\n5951\n7.15\n\n\n2023\n83106\n4444\n5.35\n7507\n9.03\n48749\n58.66\n16370\n19.70\n6036\n7.26\n\n\n2024M11*\n83335\n4357\n5.23\n7481\n8.98\n48941\n58.73\n16351\n19.62\n6205\n7.45\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - 5 ikäluokkaa\n\n0-6-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-6-vuotiaiden %-osuus oli 2024M11* yhteensä 5.23. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.25 (2022) ja -0.12 (2023)\n\n\n7-15-vuotiaat\n7-15-vuotiaiden %-osuus oli 2024M11* yhteensä 8.98. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.13 (2022) ja -0.05 (2023)\n\n\n16-64-vuotiaat\nIkäluokka 16-64-vuotiaat on suurin kooltaan. Tämän ryhmän prosenttiosuus kokonaisuudesta oli 2024M11* yhteensä 58.73. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.19 (2022) ja 0.07 (2023)\n\n\n65-79-vuotiaat\nIkäluokka 65-79-vuotiaat oli kooltaan 2024M11* yhteensä 19.62. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.1 (2022) ja -0.08 (2023)\n\n\n80+-vuotiaat\n80+-vuotiaiden %-osuus oli 2024M11* yhteensä 7.45. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.3 (2022) ja 0.19 (2023)"
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko-kuusi-ikäluokkaa",
    "href": "vaesto.html#väestönmuutokset---väestöennakko-kuusi-ikäluokkaa",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko, kuusi ikäluokkaa",
    "text": "Väestönmuutokset - Väestöennakko, kuusi ikäluokkaa\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVuosi\nYhteensä\n0-6\n0-6 %\n7-15\n7-15 %\n16-18\n16-18 %\n19-64\n19-64 %\n65-79\n65-79 %\n80+\n80+ %\n\n\n\n\n2000\n84573\n6270\n7.41\n8669\n10.25\n3254\n3.85\n51880\n61.34\n11262\n13.32\n3238\n3.83\n\n\n2001\n84439\n6059\n7.18\n8704\n10.31\n3185\n3.77\n51682\n61.21\n11418\n13.52\n3391\n4.02\n\n\n2002\n84306\n5813\n6.90\n8774\n10.41\n3072\n3.64\n51608\n61.22\n11604\n13.76\n3435\n4.07\n\n\n2003\n84561\n5748\n6.80\n8783\n10.39\n2961\n3.50\n51735\n61.18\n11772\n13.92\n3562\n4.21\n\n\n2004\n84491\n5689\n6.73\n8670\n10.26\n2981\n3.53\n51448\n60.89\n11979\n14.18\n3724\n4.41\n\n\n2005\n84455\n5728\n6.78\n8533\n10.10\n2979\n3.53\n51290\n60.73\n12028\n14.24\n3897\n4.61\n\n\n2006\n84456\n5723\n6.78\n8333\n9.87\n3066\n3.63\n50963\n60.34\n12307\n14.57\n4064\n4.81\n\n\n2007\n84523\n5780\n6.84\n8220\n9.73\n3032\n3.59\n50987\n60.32\n12270\n14.52\n4234\n5.01\n\n\n2008\n84614\n5833\n6.89\n7982\n9.43\n3094\n3.66\n50901\n60.16\n12379\n14.63\n4425\n5.23\n\n\n2009\n84844\n5897\n6.95\n7883\n9.29\n2970\n3.50\n50956\n60.06\n12523\n14.76\n4615\n5.44\n\n\n2010\n85026\n5921\n6.96\n7759\n9.13\n2997\n3.52\n50842\n59.80\n12709\n14.95\n4798\n5.64\n\n\n2011\n85078\n5896\n6.93\n7582\n8.91\n3021\n3.55\n50539\n59.40\n13072\n15.36\n4968\n5.84\n\n\n2012\n85201\n5937\n6.97\n7475\n8.77\n3058\n3.59\n50031\n58.72\n13615\n15.98\n5085\n5.97\n\n\n2013\n85399\n5924\n6.94\n7542\n8.83\n2941\n3.44\n49647\n58.14\n14200\n16.63\n5145\n6.02\n\n\n2014\n85418\n5854\n6.85\n7569\n8.86\n2755\n3.23\n49344\n57.77\n14693\n17.20\n5203\n6.09\n\n\n2015\n85363\n5783\n6.77\n7576\n8.88\n2651\n3.11\n48907\n57.29\n15085\n17.67\n5361\n6.28\n\n\n2016\n85059\n5624\n6.61\n7571\n8.90\n2618\n3.08\n48544\n57.07\n15260\n17.94\n5442\n6.40\n\n\n2017\n84587\n5430\n6.42\n7666\n9.06\n2553\n3.02\n47827\n56.54\n15554\n18.39\n5557\n6.57\n\n\n2018\n84403\n5310\n6.29\n7736\n9.17\n2589\n3.07\n47364\n56.12\n15743\n18.65\n5661\n6.71\n\n\n2019\n83934\n5076\n6.05\n7689\n9.16\n2589\n3.08\n46878\n55.85\n15909\n18.95\n5793\n6.90\n\n\n2020\n83684\n4850\n5.80\n7705\n9.21\n2656\n3.17\n46448\n55.50\n16114\n19.26\n5911\n7.06\n\n\n2021\n83482\n4739\n5.68\n7663\n9.18\n2677\n3.21\n46153\n55.28\n16179\n19.38\n6071\n7.27\n\n\n2022\n83205\n4559\n5.48\n7581\n9.11\n2764\n3.32\n45943\n55.22\n16407\n19.72\n5951\n7.15\n\n\n2023\n83106\n4444\n5.35\n7507\n9.03\n2799\n3.37\n45950\n55.29\n16370\n19.70\n6036\n7.26\n\n\n2024M11*\n83335\n4357\n5.23\n7481\n8.98\n2771\n3.33\n46170\n55.40\n16351\n19.62\n6205\n7.45\n\n\n\n\n\n\n\n\nVäestökehityksen muutos - 6 ikäluokkaa\n\n0-6-vuotiaat\nIkäluokkien kehitystä aikaisempiin vuosiin vertailtaessa 0-6-vuotiaiden %-osuus oli 2024M11* yhteensä 5.23. Jos verrataan lukemaa kahteen edellisvuoteen 2022 ja 2023, muutosta on tullut -0.25 (2022) ja -0.12 (2023)\n\n\n7-15-vuotiaat\n7-15-vuotiaiden %-osuus oli 2024M11* yhteensä 8.98. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.13 (2022) ja -0.05 (2023)\n\n\n16-18-vuotiaat\n16-18-vuotiaiden prosenttiosuus kokonaisuudesta oli 2024M11* yhteensä 3.33. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.01 (2022) ja -0.04 (2023)\n\n\n18-64-vuotiaat\nIkäluokka 18-64-vuotiaat on suurin kooltaan. Tämän ryhmän prosenttiosuus kokonaisuudesta oli 2024M11* yhteensä 58.73. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut **** (2022) ja **** (2023)\n\n\n65-79-vuotiaat\nIkäluokka 65-79-vuotiaat oli kooltaan 2024M11* yhteensä 19.62. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut -0.1 (2022) ja -0.08 (2023)\n\n\n80+-vuotiaat\n80+-vuotiaiden %-osuus oli 2024M11* yhteensä 7.45. Edellisvuosiin 2022 ja 2023 verrattuna, muutosta on tullut 0.3 (2022) ja 0.19 (2023)"
  }
]